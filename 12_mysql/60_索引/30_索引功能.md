覆盖索引
简介
什么是覆盖索引呢？
查询的结果只需要从你建立的索引列的索引中就可以获取，不需要你额外的读取其他的数据行。
这样就可以使得你的查询被你建的索引所覆盖，索引被称为覆盖索引。
条件
举例1 max
查看 select max(payment_date) from payment 的执行计划
显示rows扫描的行为16086,也就是进行了全表扫描才查询到最后的结果。
这里写图片描述

如果此时，我们在payment_date字段上面建立一个索引，这时建的就是一个覆盖索引，create INDEX idx_paydate on payment(payment_date);.
查看执行计划：
这里写图片描述

结果显示，扫描的行rows为null，也就是没有扫描就直接可以获得最后的结果。extra显示：select tables optinized away 不能再优化了。
举例2 select
查看索引
这里写图片描述

查询非索引列
全表扫描,获取数据
,,这里写图片描述

查询索引覆盖列
注意Using index,它表示从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。
这里写图片描述

举例3 innodb特殊
在大多数引擎中，只有当查询语句所访问的列是索引的一部分时，索引才会覆盖。
但是，InnoDB不限于此，InnoDB的二级索引在叶子节点中存储了primary key的值。因此，下面的查询也可以走索引覆盖.
这里写图片描述

优化排序
排序

锁优化
索引对于InnoDB非常重要，因为它可以让查询锁更少的元组。这点十分重要，因为MySQL 5.0中，InnoDB直到事务提交时才会解锁。有两个方面的原因：首先，即使InnoDB行级锁的开销非常高效，内存开销也较小，但不管怎么样，还是存在开销。其次，对不需要的元组的加锁，会增加锁的开销，降低并发性。

InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是，只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了：InnoDB已经锁住那些元组，服务器无法解锁了。
参考
http://blog.csdn.net/wangyy130/article/details/51462645