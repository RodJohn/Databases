# 概述

    将待排序的序列构造成成一个大顶堆
    将堆顶元素与末尾元素进行交换，使末尾元素最大。
    然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。
    如此反复进行交换、重建、交换。





# 构建大顶堆

## 思路
    
    从下标最大的非叶子结点开始,
    先比较左右孩子的最大点,
    用最大的孩子比较该节点,
    如果节点小于孩子,则将孩子值覆盖父节点
    并从该孩子递归

## 图解

![这里写图片描述](http://img.blog.csdn.net/20180228162726969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9kX2pvaG4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


# 算法

```
    a[]为原始数组
    i待调整的堆顶
    n为数组长度
    private static void sort(int[] arr,int t,int len){
        int temp = arr[t];
        for(int i = t*2+1 ; i < len ; i = i*2 +1){
            //获取较大的分支
            if(i+1 < len && arr[i] < arr[i+1])
                i++;
            //较大分支和父节点比较
            if(arr[i] <= temp){
                break;
            }
            //如果父节点较小,子节点值赋予父节点
            arr[t] = arr[i];
            //记录被上移位置
            t = i;
        }
        //插入
        arr[t] = temp;
    }
```


# 分析

堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。
所以堆排序时间复杂度一般认为就是O(nlogn)级。

由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次重新恢复堆操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。二次操作时间相加还是O(N * logN)。故堆排序的时间复杂度为O(N * logN)。
