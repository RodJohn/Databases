
# 概述

    先从队列中取出一个数作为枢纽值。
    将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
    然后再按此方法对这剩下的两部分分别进行排序，
    以此类推，
    最终达到整个数据变成有序序列
    
    快速排序由C. A. R. Hoare在1962年提出。
    相当于冒泡排序的升级

# 比较排序

## 思路

    先从队列中取出一个数作为枢纽值。
    依次从尾部找比基准小的数,交换位置,则此时他后面的数都比他大,并将此位置记录为新的尾部;
    依次从头部找比基准大的数,交换位置,则此时他前面的数都比她小,并将此位置记录为新的头部;
    不断交替交换,最终找出枢纽值在队列中的位置
    

## 图解

![这里写图片描述](http://img.blog.csdn.net/20180228114228308?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9kX2pvaG4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 简单算法

```
    private static int quick(int[] arr,int left,int right){
        //任意选取一个作为枢纽值
        int mid = arr[left];
        while(left < right){
            //找出尾部比枢纽值小的数
            while(arr[right] >= mid && right>left)
                right--;
            MyArrayTool.swap(arr,left,right);
            //找出头部比枢纽值大的数
            while (mid >= arr[left] && right>left)
                left++;
            MyArrayTool.swap(arr,left,right);

        }
        //返回枢纽值位置
        return left;
    }
```

# 优化

## 枢纽值

    在分割的过程中，枢纽值的选择至关重要，
    如果枢纽值为极值,这一轮的排序对队列将无影响

三数取中法

　　取左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值。

## 优化交换

    在前面的交换排序中,
    枢纽值经过多次交换到最终的位置
    其实每次使用交换值直接替换当前枢纽值位置即可


# 完整算法

```
    private static void sort(int[] arr,int left,int right){
        if(left < right){
            int mid = quick(arr,left,right);
            sort(arr,left,mid-1);
            sort(arr,mid+1,right);
        }
    }
```

# 复杂度
    
    递归次数
        递归次数相当于完全二叉树的深度:log2n    
    比较次数
        每层的比较次数:n-深度
    平均时间复杂度也为O(nlogn)级。

# 分析

    像是二叉树排序