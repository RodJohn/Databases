
# 3 RDB

## 3.1 概述

    用二进制的方式完整的保存某个时刻的数据
    
## 3.2 特点

优点

    1.rdb持久化文件很紧凑，占用空间更小。 
    2.rdb保存的是基于时间点的数据快照
    3.利用rdb文件进行数据恢复时，速度更快

缺点

    1.会造成部分数据的丢失 
    2.修改频繁时,   完整备份

## 3.5 保存命令

### 3.5.1 save

    使用主进程进行备份
    
    阻塞客户端
    
### 3.5.2 bgsave

    1.redis调用fork函数复制主进程
    2.子进行将内存中的数据写入一个临时的dump文件
    3.子进程写入完成后，会用新的临时dump文件替换就的rdb文件
    4.父进程继续接收并处理客户端发来的命令,
    5.父子进程共用相同的物理内存,使用COW的策略保证最终一致性
        当父进程要更改其中某片数据时（如执行一个写命令 ），
        操作系统会将该片数据复制一份以保证子进程的数据不受影响，
        所以新的RDB文件存储的是执行fork那一刻的内存数据
    
    不阻塞客户端
    内存的使用大

## 3.6 自动保存

概述

    通过设置save配置,让服务器根据规则自动执行bgsave

规则

    save time minupdatecount    
   

### 3.8 恢复


    Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。
    根据数据量大小与结构和服务器性能不同，这个时间也不同。
    通常将一个记录一千万个字符串类型键、大小为1GB的快照文件载入到内 存中需要花费20～30秒钟。 
       


# 5 AOF

## 5.1 概述

    写操作记录

## 5.2 特点

优点

    1.通过精细的fsync策略(always/everysec),达到保存更完整的数据
    3.aof重写机制确保aof文件不会过大 

缺点

    1.虽然有aof重写机制，单aof文件通常比rdb文件大 
    2.在不同的fsync策略写，redis性能会受到一定影响

    

## 5.6 保存    

开启

    aof机制默认关闭，
    设置appendonly = yes参数,开启aof机制，
    设置appendfilename = myaoffile.aof,指定aof文件名称。

过程

    命令先保存到aof缓存区
    根据fsync策略,保存命令到文件中
    
设置

    修改aof的fsync策略：

    appendfsync=always   同步持久化每一次修改操作
    appendfsync=everysec   每秒想aof文件同步一次
    appendfsync=no         关闭向aof文件写入修改

  
    
## 5.7 重写

原理
    
    从数据库中读取键现在的值，
    然后用一条命令去记录键值对，忽略掉之前记录该键值对的多个命令;

重写进程

    1.建立新的子进程进行AOF重写
    2.主进程接受到命令后会将数据保存到AOF重写缓冲区
    3.子进程完成重写后,父进程将AOF重写缓存中的内容全部写入到新的AOF文件中

配置规则

    
## 5.8 还原

    在服务器启动时重新执行这些命令来恢复数据集。
    优先从AOF中读取
    
# 6 最佳实践 


    只要是 保存  都会降低响应时间 和 使用更多的内存
    




        