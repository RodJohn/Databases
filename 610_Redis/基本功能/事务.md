



一般情况下,是没有事务的,所有的命令都是自动提交



redis只能保证一个client发起的事务中的命令可以连续的执行，而中间不会插入其他client的命令。 由于redis是单线程来处理所有client的请求的所以做到这点是很容易的。一般情况下redis在接受到一个client发来的命令后会立即处理并 返回处理结果，但是当一个client在一个连接中发出multi命令有，这个连接会进入一个事务上下文，该连接后续的命令并不是立即执行，而是先放到一 个队列中。当从此连接受到exec命令后，redis会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到一起返回给client.然后此连接就 结束事务上下文。


批量操作


命令
	MULTI 
标记一个事务块的开始。
	EXEC 
执行所有事务块内的命令。
DISCARD 
取消事务，放弃执行事务块内的所有命令。


WATCH key [key ...] 
监视一个(或多个) key ，
如果在事务执行之前key 被其他连接的命令所改动，那么事务将被打断。
UNWATCH 
取消 WATCH 命令对所有 key 的监视。

	
例子
	
批量操作
以 MULTI 开始一个事务，
然后将多个命令入队到事务中，
最后由 EXEC 命令触发事务， 一并执行事务中的所有命令.

192.168.2.129:6379> multi
OK
192.168.2.129:6379> set name "zhangsan"
QUEUED
192.168.2.129:6379> set age 20
QUEUED
192.168.2.129:6379> exec
1) OK
2) OK
192.168.2.129:6379> keys *
1) "age"
2) "name"
192.168.2.129:6379>

取消
	取消事务，放弃执行事务块内的所有命令。
	192.168.2.129:6379> multi
OK
192.168.2.129:6379> set name2 "lisi"
QUEUED
192.168.2.129:6379> set age 22
QUEUED
192.168.2.129:6379> discard
OK
192.168.2.129:6379> exec
(error) ERR EXEC without MULTI
192.168.2.129:6379>


乐观锁

WATCH 对key值进行锁操作。 
在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 key 的值， 那么当前客户端的事务就会失败。

Client1开启watch name并在事务中修改name，但是没有执行exec
192.168.2.129:6379> get name
"huangliu"
192.168.2.129:6379> watch name
OK
192.168.2.129:6379> multi
OK
192.168.2.129:6379> set name lisi
QUEUED


Client2 修改name
192.168.2.129:6379> get name
"huangliu"
192.168.2.129:6379> set name "wangwu"
OK
192.168.2.129:6379> get name
"wangwu"
192.168.2.129:6379>


Client1执行exec
192.168.2.129:6379> exec
(nil)
192.168.2.129:6379>

可见，由于被watch的name已经被Client2 修改，所以Client1的事务执行失败，程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞（Crash）为止。对key进行加锁监视的机制类似Java多线程中的锁（synchronized中的监视器对象），被称作乐观锁。






参考
http://www.cnblogs.com/xhan/archive/2011/02/04/1949151.html
