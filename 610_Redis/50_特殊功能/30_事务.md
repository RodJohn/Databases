

# redis事务


    默认情况下,是没有事务的,所有的命令都是自动提交
    Redis的事务将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制
    并且在事务的执行期间，服务器不会打断事务而改去执行其他客户端的命令请求，
    它会将事务中的所有命令都执行完毕，然后才去执行其他客户端的命令请求。 

# 完整过程

加锁
    
    使用WATCH对指定键加乐观锁

开始事务

    在客户端执行一个MULTI命令，标记一个事务块的开始

命令入队

    将客户端的命令用队列的形式保存起来

执行检测

    在客户端执行EXEC命令后，先执行事务检查
    如果 1.命令入队时有语法错误 2.被监控的key被修改
    则中断exec,事务失败,提示nil信息 
        
执行事务    
    
    先调用unwatchAllKeys()函数，解除当前客户端所监视的所有命令。
    然后遍历事务队列中的所有命令，
    如果中间某个命令失败,
    将继续执行后面的命令,操作不会回滚
    执行完毕会调用discardTransaction()函数取消当前客户端的事务状态。
    
    
# 分析

## ACID

    原子性:
        全部执行或者全部不执行-(watch,语法检测)  
    一致性:
        持久化--宕机
        失败不回滚(提前做好检测)
    隔离性:  
        单线程隔离很好

## 分析

   事务可用,不是很严谨
   一般的问题都是因为业务bug
   语法错误可以通过代码覆盖率测试避免
   业务逻辑


# 命令

MULTI 
    
    标记一个事务块的开始。 
    随后的指令将在执行EXEC时作为一个原子执行。
    
EXEC 

    执行事务中所有在排队等待的指令并将链接状态恢复到正常

DISCARD 

    取消事务，放弃执行事务块内的所有命令。


WATCH key [key ...] 

    监视一个(或多个) key ，
    如果在事务执行之前key 被其他连接的命令所改动，那么事务将被打断。
    
UNWATCH 

    取消一个事务中已被监视的所有key。
    如果执行EXEC 或者DISCARD， 则不需要手动执行UNWATCH 。

	
# 例子
	
事务
	
    以 MULTI 开始一个事务，
    然后将多个命令入队到事务中，
    最后由 EXEC 命令触发事务， 一并执行事务中的所有命令.
    
    192.168.2.129:6379> multi
    OK
    192.168.2.129:6379> set name "zhangsan"
    QUEUED
    192.168.2.129:6379> set age 20
    QUEUED
    192.168.2.129:6379> exec
    1) OK
    2) OK
    192.168.2.129:6379> keys *
    1) "age"
    2) "name"
    192.168.2.129:6379>
    
    
    
乐观锁
    
    WATCH 对key值进行锁操作。 
    在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 key 的值， 那么当前客户端的事务就会失败。
    
    Client1开启watch name并在事务中修改name，但是没有执行exec
    192.168.2.129:6379> get name
    "huangliu"
    192.168.2.129:6379> watch name
    OK
    192.168.2.129:6379> multi
    OK
    192.168.2.129:6379> set name lisi
    QUEUED
    
    
    Client2 修改name
    192.168.2.129:6379> get name
    "huangliu"
    192.168.2.129:6379> set name "wangwu"
    OK
    192.168.2.129:6379> get name
    "wangwu"
    192.168.2.129:6379>
    
    
    Client1执行exec
    192.168.2.129:6379> exec
    (nil)
    192.168.2.129:6379>
    
    可见，由于被watch的name已经被Client2 修改，所以Client1的事务执行失败，程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞（Crash）为止。对key进行加锁监视的机制类似Java多线程中的锁（synchronized中的监视器对象），被称作乐观锁。
    


事务的原子性
实现乐观锁  秒杀



问题

key要在同一个slot上----服务定制/hash tags


# 管道
    
redis是服务是请求响应模式
网络发起传输
服务器的处理
    
过程

    使用pipeline一次提交多个命令   

pipeline
批量 
暂存结果
 

# lua脚本
2.6以后出现
lua脚本本身就是一种事务


参考
http://www.cnblogs.com/xhan/archive/2011/02/04/1949151.html
