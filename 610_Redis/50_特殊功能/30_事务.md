

事务 MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务的基础事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断事务中的命令要么全部被执行，要么全部都不执行，EXEC 命令负责触发并执行事务中的所有命令  Redis 的 Transactions 提供的并不是严格的 ACID 的事务Transactions 还是提供了基本的命令打包执行的功能： 可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行Redis 还提供了一个 Watch 功能，你可以对一个 key 进行 Watch，然后再执行 Transactions，在这过程中，如果这个 Watched 的值进行了修改，那么这个 Transactions 会发现并拒绝执行

绝大多数NoSQL选择不支持事务，而Reids以命令方式（MULTI, EXEC, DISCARD, WA WATCH）提供了简单的

类/伪事务支持，之所以称之为类/伪事务，是因为Redis的只保证了事务必须ACID的C（一致性），I（隔离性），

并不保证A（原子性）与持久性（D），Redis事务甚至不支持回滚操作。



实际上，Redis的事务提供了一种将多个命令打包并置入事务队列，之后批量一次性，有序的按照先进先出

（FIFO）的顺序执行机制。事务在执行过程中不会被中断，所有命令命令执行之后，事务才结束。

一般情况下,是没有事务的,所有的命令都是自动提交

# 原理

不会被其他客户端打断
redis只能保证一个client发起的事务中的命令可以连续的执行，而中间不会插入其他client的命令。
 由于redis是单线程来处理所有client的请求的所以做到这点是很容易的。
 一般情况下redis在接受到一个client发来的命令后会立即处理并 返回处理结果，
 但是当一个client在一个连接中发出multi命令有，这个连接会进入一个事务上下文，
 该连接后续的命令并不是立即执行，而是先放到一 个队列中。
 当从此连接受到exec命令后，redis会顺序的执行队列中的所有命令。
 并将所有命令的运行结果打包到一起返回给client.然后此连接就 结束事务上下文。

## 特点

    失败不回滚
    
    exec之前出错
    执行中出错

# 命令

批量操作


命令
	MULTI 
标记一个事务块的开始。
	EXEC 
执行所有事务块内的命令。
DISCARD 
取消事务，放弃执行事务块内的所有命令。


WATCH key [key ...] 
监视一个(或多个) key ，
如果在事务执行之前key 被其他连接的命令所改动，那么事务将被打断。
UNWATCH 
取消 WATCH 命令对所有 key 的监视。

	
# 例子
	
批量操作
以 MULTI 开始一个事务，
然后将多个命令入队到事务中，
最后由 EXEC 命令触发事务， 一并执行事务中的所有命令.

192.168.2.129:6379> multi
OK
192.168.2.129:6379> set name "zhangsan"
QUEUED
192.168.2.129:6379> set age 20
QUEUED
192.168.2.129:6379> exec
1) OK
2) OK
192.168.2.129:6379> keys *
1) "age"
2) "name"
192.168.2.129:6379>

取消
	取消事务，放弃执行事务块内的所有命令。
	192.168.2.129:6379> multi
OK
192.168.2.129:6379> set name2 "lisi"
QUEUED
192.168.2.129:6379> set age 22
QUEUED
192.168.2.129:6379> discard
OK
192.168.2.129:6379> exec
(error) ERR EXEC without MULTI
192.168.2.129:6379>


乐观锁

WATCH 对key值进行锁操作。 
在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 key 的值， 那么当前客户端的事务就会失败。

Client1开启watch name并在事务中修改name，但是没有执行exec
192.168.2.129:6379> get name
"huangliu"
192.168.2.129:6379> watch name
OK
192.168.2.129:6379> multi
OK
192.168.2.129:6379> set name lisi
QUEUED


Client2 修改name
192.168.2.129:6379> get name
"huangliu"
192.168.2.129:6379> set name "wangwu"
OK
192.168.2.129:6379> get name
"wangwu"
192.168.2.129:6379>


Client1执行exec
192.168.2.129:6379> exec
(nil)
192.168.2.129:6379>

可见，由于被watch的name已经被Client2 修改，所以Client1的事务执行失败，程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞（Crash）为止。对key进行加锁监视的机制类似Java多线程中的锁（synchronized中的监视器对象），被称作乐观锁。

--- 

事务的原子性
实现乐观锁  秒杀



问题

key要在同一个slot上----服务定制/hash tags




pipeline
只是批量 
 

lua脚本
2.6以后出现
lua脚本本身就是一种事务


参考
http://www.cnblogs.com/xhan/archive/2011/02/04/1949151.html
