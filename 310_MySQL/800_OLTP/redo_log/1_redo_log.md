

# 概述

redo log 
    
    保证事务的持久性
    记录了页的更改(innodb)
    
    
    
    redo log用于恢复提交事务的修改
    
# 流程


    在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。
    事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，
    在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。
    
    
    当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。
    此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。
    未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。
    
    
    1.产生redo log info
    2.写入redo log buffer
    3.写入redo log file

     1.重做日志信息 先写入 重做日志缓冲 再按一定条件顺序写入重做日志文件！
     2.redo log buffer 向 redo log file 写，是按512个字节，也就是一个扇区的大小进行写入。扇区是写入的最小单位，一定能写入成功，因此过程中不需要double write.   

    重做日志写入过程

    在innodb的引擎实现中，为了实现事务的持久性，构建了重做日志系统。重做日志由两部分组成：内存日志缓冲区(redo log buffer)和重做日志文件。
    日志缓冲区是为了加快写日志的速度，而重做日志文件为日志数据提供持久化的作用。
    redo log 由 redo log buffer 和 redo log file 构成    

3.重做日志结构和关系图

     innodb在重做日志实现当中，设计了3个层模块，即redo log buffer、group files和archive files。这三个层模块的描述如下：
    
    redo log buffer        重做日志的日志内存缓冲区，新写入的日志都是先写入到这个地方.redo log buffer中数据同步到磁盘上，必须进行刷盘操作。
    
    group files       重做日志文件组，一般由3个同样大小的文件组成。3个文件的写入是依次循环的，每个日志文件写满后，即写下一个，日志文件如果都写满时，会覆盖第一次重新写。重做日志组在innodb的设计上支持多个。
    
    archive files         归档日志文件，是对重做日志文件做增量备份，它是不会覆盖以前的日志信息。
      
    重做日志组
    重做日志组可以支持多个，这样做的目的应该是为了防止一个日志组损坏后，可以从其他并行的日志组里面进行数据恢复。在MySQL-5.6的将日志组的个数设置为1，不允许多个group存在。网易姜承尧的解释是innodb的作者认为通过外层存储硬件来保证日志组的完整性比较好，例如raid磁盘。重做日志组的主要功能是实现对组内文件的写入管理、组内的checkpoint建立和checkpiont信息的保存、归档日志状态管理（只有第一个group才做archive操作）






# 总结
       Innodb的重做日志系统是相当完备的，它为数据的持久化做了很多细微的考虑,它效率直接影响MySQL的写效率，所以我们深入理解了它便以我们去优化它，尤其是在大量数据刷盘的时候。假设数据库的受理的事务速度大于磁盘IO的刷入速度，一定会出现同步建立checkpoint操作，这样数据库是堵塞的，整个数据库都在都在进行脏页刷盘。避免这样的问题发生就是增加IO能力，用多磁盘分散IO压力。也可以考虑SSD这读写速度很高的存储介质来做优化。

         
# 參考

    https://yq.aliyun.com/articles/219?spm=5176.100240.searchblog.93#13         