

#隔离级别和锁

	在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。数据库锁，实现这些隔离级别存在的。


# 隔离级别


## Read Uncommitted

定义
   
    未提交读(Read Uncommitted)
	
特点
	
	可以读取到其他事务中未提交的修改(脏读)

举例

    (脏读问题)


## READ COMMITTED
	
定义
	
    提交读
    (Read Committed)

特点

	能读取到已经提交的数据。
	解决脏读问题.会发生不可重复读现象.
	
不可重复读
    
    (不可重复读的问题)
    事务B开启时读到数据1，接下来事务A开启，把这个数据改成2，提交，B再次读取这个数据，会读到最新的数据2。

    不可重复读是原先查询出来的数据发生更改.重点在于update和delete，
    同一条记录 两次结果不一样
    解决方法是在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。

应用

    Oracle等多数数据库默认都是重复读.
    
    
## REPEATABLE READ

定义
	
    可重复读(Repeated Read)

特点
	
	解决不可重复读，但是还存在幻象读(innodb解决了)
	

幻读

    (幻读问题)
	当某个事务在读取某个范围内的值的时候，
	另外一个事务在这个范围内插入了新记录，
	那么之前的事务再次读取这个范围的值，
	会读取到新插入的数据。
	
	幻读的重点在于insert。
	读到了上次不存在的数据
	当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，
	不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥.
	
	

应用

    Mysql默认的隔离级别是RR，
    然而mysql的innoDB引擎间隙锁成功解决了幻读的问题。    

## SERIALIZABLE
	
定义
	
    串行读(Serializable)
    可串行化是最高的隔离级别。

特点
	
	完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞
    


# 影响
    
    幻读
    
    有什么影响呢
     

# 并发

    隔离级别越高，它所带来的资源消耗也就越大(锁)，因此它的并发性能越低


# mysql 语法    
    
设置隔离级别
	
	
	set session transaction isolatin level repeatable read;
	set global transaction isolation level repeatable read;
	
查看隔离级别
 
	select @@tx_isolation;
	select @@global.tx_isolation;



MySQL中支持事务的存储引擎有innoDB和NDB。innoDB是MySQL默认的存储引擎，默认的隔离级别是RR，并且在RR的隔离级别下更进一步，通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。因此innoDB的RR隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。