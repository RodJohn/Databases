
https://blog.csdn.net/tianjiabin123/article/details/72625156



latch
lock

行锁 页锁 表锁


运行机制
意向锁
 层级锁
    对一棵树进行加锁
        库 表 页 记录
 多粒度锁
 InnoDb 的意向锁只能加在表级别上 
 
 Innodb 没有锁升级

 innodb锁的是索引 


加锁语句
    
    for update  
    lock in share

    设置参数 innodb_status_output_locks 
    
    show engine innodb status 

    细节的锁信息
    判别SQL锁了多少数据
    
    innodb_trx
    innodb_locks
    innodb_lock_waits
        阻塞
        锁住 space page_no heap_no
        info bits 记录状态
        blocking query 不准确 
        
        

锁超时

    innodb_lock_wait_timeout
    正常
    
    
   锁-->并发控制-->隔离级别-->序列化 (一个概念)
   
   
   
   
隔离级别

    一个事务所作的修改对其他的事务是不可见的 
    就像事务之间是串行执行的
    
     
    级别 
        
        oracle mysql 
        rc 不满足 acid 
        
        mysql的rr 避免幻读 实现完整    
    
    为什么
        1 3 5 7
        
        trx del <= 7
        trx insert 6
        
        


锁算法

    为了解决并发问题

    record lock
        记录锁
        单个行记录加锁
    gap lock
        间隙锁
        锁定一个范围 但不包括记录本身
    next-key lock
        record lock + gap lock
        
        rr级别 从开始玩下寻找到第一个不是的记录 
        主键索引
        辅助索引
        被锁住的数据    
        
    默认就是 next-gap lock
        
        可能降级为记录锁
        
    info bit 32 标记已删除    
         
    
    插入意向锁
    

非锁定读

    MVCC    
    
死锁

    AB -BA 死锁
    
    唯一索引 死锁
    
        SQL_SEVER update锁可以减少
    
自增锁


    AI
    自增列
    在事务提交之前释放
    使用完就释放{(就像是latch)  否则等待时间太长
    
    有回滚id 不连续
        
    
    innodb_autoinrc_lock_mode
        0
            latch
        1 默认
            simple insert 并发
            bulk imsert 占用
        2
            
            
    auto_increment_incrcement 初始值 步长            
    
 
插入类型
    
    
    
    insert on duplicate key update 不稳定       
    
    
    