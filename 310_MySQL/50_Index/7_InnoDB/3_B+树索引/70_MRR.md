

# 1 概述

定义

    MRR全称是Multi-Range Read
    二次查询时的主键排序读取
    二级索引合并回表
    辅助索引范围读取优化
    
作用

    在使用二级索引做范围扫描的过程中减少磁盘随机IO和减少主键索引的访问次数。将随机IO转换为顺序IO

版本

    InnoDB1.2 (MYSQL5.6)

## 设置

参数

    用optimizer_switch的标记来控制是否使用MRR.设置mrr=on时，表示启用MRR优化。
    mrr_cost_based表示是否通过cost base的方式来启用MRR.
    当mrr=on,mrr_cost_based=on,则表示cost base的方式还选择启用MRR优化,当发现优化后的代价过高时就会不使用该项优化
    当mrr=on,mrr_cost_based=off,则表示总是开启MRR优化

查询    
    
    Select @@optimizer_switch;
    默认不开启    

设置

    SET  @@optimizer_switch='mrr=on,mrr_cost_based=on';    



# 3 原理

## 3.1 普通查找

    先通过辅助索引查找到对应的主键id，
    再通过主键id找到对应的数据页，
    在数据页中最后通过二分查找找到对应的数据。

    
# 5 主键排序 

## 5.1 原理

    在通过辅佐索引页上拿到主键id后，并不是通过id直接去数据页中取数据。
    而是先通过排序算法，把取到的主键id按照从小到大的方式排序，然后再去取对应的数据。这样就可以把随机io的情况降到最低。

## 5.3 效果


减少随机IO

    
    如果通过辅助索引找到的主键是有多个,势必每次取到的id不一定是顺序的，既然不会是顺序的，那么必然会产生一定的随机io。
    在计算机中，随机io的速度比顺序的io的速度慢很多，因为在一个柱面中，随机io必然会造成磁头的随机旋转，从而产生一定量的磁盘io，而顺序io则可降低到最低。

减少缓冲池更改   
    
    没有启用mrr优化之前，
    由于主键的id是随机取的，那么可能每次取到的数据都不在同一个页中。
    比如第一个数据在一个页中，第二个数据又在另一个页中，而第三个数据又在第一个页中，
    在缓冲池不够大的时候，这样的情况会造成缓冲池中的页不断的离开缓冲池，然后又进入缓冲池，从而造成缓冲池的热点数据频繁更新。
    而启用了mrr优化以后，由于主键是顺序的，则可以把此开销降为最低。
    避免了缓冲池中页的频繁更改。




# 7 拆分多条件范围查询

## 原理

    MRR可以将某些范围查询，拆分为键值对，来进行批量的数据查询，如下：

    表t上有二级索引(key_part1, key_part2)，索引根据key_part1,key_part2的顺序排序。
    SELECT * FROM tWHERE key_part1 >= 1000 AND key_part1 < 2000 AND key_part2 = 10000;
  
    
    若不使用MRR：
        索引扫描会将key_part1在1000到2000的索引元组，然后判断key_part2的值
        导致大量无效数据被取出
    
    若使用MRR：
        优化器将查询条件拆分为多个单点间隔[{1000, 10000}], ..., [{1999, 10000}] 


# 9 实践





# 参考

    官方文档
    https://dev.mysql.com/doc/refman/8.0/en/mrr-optimization.html
    
    http://blog.itpub.net/31003153/viewspace-2091261/
    