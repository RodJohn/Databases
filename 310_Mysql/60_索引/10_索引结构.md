
http://blog.codinglabs.org/articles/theory-of-mysql-index.html

B树
即二叉搜索树

每个结点只存储一个关键字，等于则命中，小于走左结点，大于 
走右结点

   1.所有非叶子结点至多拥有两个儿子（Left和Right）；
   2.所有结点存储一个关键字；
   3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；
这里写图片描述

搜索
B树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；
否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入
右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；

如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；
特点
但它比连续内存空间的二分查找的优点是，改变B树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；
这里写图片描述

平衡树
这里写图片描述

右边也是一个B树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的
树结构索引；所以，使用B树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就
是所谓的“平衡”问题；      
实际使用的B树都是在原B树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树
结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的
策略；
B-树
多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键
字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

   是一种多路搜索树（并不是二叉的）：
   1.定义任意非叶子结点最多只有M个儿子；且M>2；
   2.根结点的儿子数为[2, M]；
   3.除根结点以外的非叶子结点的儿子数为[M/2, M]；
   4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
   5.非叶子结点的关键字个数=指向儿子的指针个数-1；
   6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
   7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的
子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
   8.所有叶子结点位于同一层；
这里写图片描述

搜索
从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果
命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为
空，或已经是叶子结点；
特性
   1.关键字集合分布在整颗树中；
   2.任何一个关键字出现且只出现在一个结点中；
   3.搜索有可能在非叶子结点结束；
   4.其搜索性能等价于在关键字全集内做一次二分查找；
   5.自动层次控制；
B+树
   B+树是B-树的变体，也是一种多路搜索树：
   1.其定义基本与B-树同，除了：
   2.非叶子结点的子树指针与关键字个数相同；
   3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树
（B-树是开区间）；
   5.为所有叶子结点增加一个链指针；
   6.所有关键字都在叶子结点出现；
这里写图片描述

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在
非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；
       B+的特性：
       1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好
是有序的；
       2.不可能在非叶子结点命中；
       3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储
（关键字）数据的数据层；
       4.更适合文件索引系统；
B*树
在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；
mysql索引和树
MyISam
MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。
下图是MyISAM索引的原理图： 
这里写图片描述

这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：

这里写图片描述

同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 
MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。

InnoDB
虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。
第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
这里写图片描述

上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：

这里写图片描述

这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调(可能是指“非递增”的意思)的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调(可能是指“非递增”的意思)的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

# 参考
http://blog.csdn.net/superhosts/article/details/25611119

http://blog.codinglabs.org/articles/theory-of-mysql-index.html