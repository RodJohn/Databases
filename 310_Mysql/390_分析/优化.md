mysq 数据优化可以从以下几方面进行优化：

1、sql及索引优化。 
2、 数据库表结构，根据数据设计查询最优的表结构。 
3，系统配置优化，对打开文件数和安全的限制。 
系统配置之打开文件数限制：mysql数据库是基于文件的，每查询一个表都要打开一些文件，文件数达到一定限制，文件就无法打开，就会进行频繁的IO操作 
4、硬件，选择最适合数据库的cpu，更快的IO,更大的内存， 
cpu不是越多越好， IO并不能减少锁的机制，所以说硬件的优化成本越高，效果最差。

1 SQL及索引（提升性能最大，效率最高） 
2 数据库表结构（根据范式设计表结构） 
3 系统配置（linux对mysql打开文件数的限制等） 
4 硬件（提高文件io的速度，但是成本最高） 
io的优化 并不能减少阻塞 ，但sql索引没有优化好，则会产生大量的慢查询或阻塞，这是由于mysql的内部锁机制造

自身锁机制

mysql查询缓存

缓存 
想办法提高缓冲池子命中率

数据分离 
表结构 
减少使用distinct 
索引 
缓存

数据分离 
静态数据的分离 
表结构 
减少使用distinct 
积分统计表 按照积分排序 
索引 
考虑让SQL 语句走索引，注意建立索引但不一定会走索引，根据SQL执行计划让SQL走索引

缓存

看报错

查询慢sql

数据库慢sql日志

http://www.cnblogs.com/kerrycode/p/5593204.html

死锁

http://blog.jobbole.com/110301/?utm_source=blog.jobbole.com&utm_medium=relatedPosts

1缓存

当只要一行数据时使用 LIMIT 1

2.索引

为搜索字段建索引

排序

避免 SELECT *

尽可能的使用 NOT NULL

Prepared Statements

果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了

禁用select * 
使用select count(*) 统计行数 
尽量少运算 
尽量避免全表扫描，如果可以，在过滤列建立索引 
尽量避免在where子句对字段进行null判断 
尽量避免在where子句使用!= 或者<> 
尽量避免在where子句使用or连接 
尽量避免对字段进行表达式计算 
尽量避免对字段进行函数操作 
尽量避免使用不是复合索引的前缀列进行过滤连接 
尽量少排序，如果可以，建立索引 
尽量少join 
尽量用join代替子查询 
尽量避免在where子句中使用in,not in或者having，使用exists,not exists代替 
尽量避免两端模糊匹配 like %*% 
尽量用union all代替union 
尽量早过滤 
避免类型转换 
尽量批量insert 
优先优化高并发sql，而不是频率低的大sql
